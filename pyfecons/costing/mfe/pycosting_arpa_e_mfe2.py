# -*- coding: utf-8 -*-
"""PyCosting_ARPA-E_MFE2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Yq--IZYLV3gJ5dJqAjgoYWdbz4y8XwcV

# PyFECONS
"""

project="MFE"

from google.colab import drive
drive.mount('/content/drive/')

#INSTALL PACKAGES
#----FIRST TIME ONLY------
#Have to do this every time colab resets :/
!pip install PyLaTeX
!apt-get install texlive texlive-xetex texlive-latex-extra pandoc
!apt-get update
#!apt-get install texlive texlive-xetex texlive-latex-extra pandoc
#!apt-get install --fix-missing texlive texlive-xetex texlive-latex-extra pandoc
!pip install cadquery

# Commented out IPython magic to ensure Python compatibility.
#Git handling
#----FIRST TIME ONLY------
from getpass import getpass
import os
os.environ['GITHUB_AUTH'] = getpass('Enter your GitHub token: ')
!git clone https://$GITHUB_AUTH@github.com/Alex-WSci/Costing_ARPA-E_MFE
#AUTH TOKEN:
#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
!git config --global user.name "Alex-WSci"
!git config --global user.email "alex@woodruffscientific.com"
# %cd /content/Costing_ARPA-E_MFE
!ls

"""# Cost Code
(run from here when making updates)
"""

#Libraries

materials = {
    "FS": {"rho": 7470, "c_raw": 10, "m": 3, "sigma": 450},
    "Pb": {"rho": 9400, "c_raw": 2.4, "m": 1.5},
    "Li4SiO4": {"rho": 2390, "c_raw": 1, "m": 2},
    "Flibe": {"rho": 1900, "c": 40},
    "W": {"rho": 19300, "c_raw": 100, "m": 3},
    "Li": {"rho": 534, "c_raw": 70, "m": 1.5},
    "BFS": {"rho": 7800, "c_raw": 30, "m": 2},
    "PbLi": {"rho": None, "c": None},  # To be calculated
    "SiC": {"rho": 3200, "c_raw": 14.49, "m": 3},
    "Inconel": {"rho": 8440, "c_raw": 46, "m": 3},
    "Cu": {"rho": 7300, "c_raw": 10.2, "m": 3},
    "Polyimide": {"rho": 1430, "c_raw": 100, "m": 3},
    "YBCO": {"rho": 6200, "c": 55},
    "Concrete": {"rho": 2300, "c_raw": 13/25, "m": 2},
    "SS316": {"rho": 7860, "c_raw": 2, "m": 2, "sigma": 900},
    "Nb3Sn": {"c": 5},
    "Incoloy": {"rho": 8170, "c_raw": 4, "m": 2},
    "GdBCO": {},  # Density and cost not provided
    "He": {},  # Density and cost not provided
    "NbTi": {},  # Density and cost not provided
}

pblir = 10
materials["PbLi"]["rho"] = (materials["Pb"]["rho"] * pblir + materials["Li"]["rho"]) / (pblir + 1)
materials["PbLi"]["c"] = (materials["Pb"]["c_raw"] * materials["Pb"]["m"] * pblir + materials["Li"]["c_raw"] * materials["Li"]["m"]) / (pblir + 1)



blanket = {
    "firstWall": ["tungsten", "liquid metal", "beryllium", "molten salt"],
    "blanketType": [
        "flowing liquid first wall",
        "solid first wall with a liquid breeder",
        "solid first wall with a solid breeder (Li4SiO4)",
        "solid first wall with a solid breeder (Li2TiO3)",
        "solid first wall, no breeder (anuetronic fuel)"
    ],
    "primaryCoolant": [
        "Lead Lithium (PbLi)", "Lithium (Li)", "FLiBe",
        "other eutectic salt", "helium",
        "dual coolant: PbLi and He", "water"
    ],
    "secondaryCoolant": [
        "no", "Lead Lithium (PbLi)", "Lithium (Li)", "FLiBe",
        "other eutectic salt", "helium",
        "dual coolant: PbLi and He", "water"
    ],
    "neutronMultiplier": [
        "no", "Be", "Pb", "Pb as part of PbLi", "Be12Ti"
    ],
    "structure": [
        "Stainless Steel (SS)", "Ferritic Martensitic Steel (FMS)",
        "Oxide Dispersion Strengthened (ODS) Steel", "Vanadium"
    ]
}

volumes = {
    "Reactor": "CATF",  # Material volumes
    "V_Cc": 6.26E+03,   # m^3 Volume inside reflector
    "V_bio": 6.36E+03,  # m^3 Concrete Shield
    "V_FW": 0.00E+00,   # m^3 Flibe
    "V_OBI": 4.62E+02,  # m^3 Blanket
    "V_HTS": 3.61E+02,  # m^3 High Temperature Shield
    "V_VV": 0.00E+00,   # m^3 Vacuum Vessel
    "V_pipes": 7.96E+06,  # m^3 Pipes
    "V_pump": 6.00E+07,   # m^3 Pump
    "V_exchanger": 6.70E+07,  # m^3 Heat exchanger
    "V_caps": 1.50E+08   # m^3 Pulsed power envelope
}

#Basic inputs

timetoReplace=10 #years
downTime=1 #years
reactorType=2 #2 is IFE, 1 is MFE, 3 is MFE %input
NMOD=1 #input
AM=1 #input
constructionTime=3 #input

firstW = blanket["firstWall"][1]
blanketT = blanket["blanketType"][0]
primaryC = blanket["primaryCoolant"][0]
secondaryC = blanket["secondaryCoolant"][7]
neutronM = blanket["neutronMultiplier"][3]
structure1 = blanket["structure"][1]

import math
from IPython.display import IFrame
import numpy as np
import matplotlib.pyplot as plt
from google.colab import drive
import pandas as pd
from scipy.interpolate import LinearNDInterpolator

#Overwriting function
#1)Reads file from 'Originals' directory
#2)Generates copy
#3)Searches copy for placeholders
#4)Overwrites placeholders in copy
#5)Saves copied and overwritten file into 'Modified' directory
import shutil

original_directory = os.path.join("/content/drive/MyDrive/2023ARPAECosting", project, "Latex", "Originals")
modified_directory = os.path.join("/content/drive/MyDrive/2023ARPAECosting", project, "Latex", "Modified")
figures_directory = os.path.join("/content/drive/MyDrive/2023ARPAECosting", project, "Figures")

def copy_file(filename):
    """
    Copy the file from the original directory to the modified directory.
    """
    original_path = os.path.join(original_directory, filename)
    modified_path = os.path.join(modified_directory, filename)

    try:
        shutil.copyfile(original_path, modified_path)
        print(f"Copied {original_path} to {modified_path}.")
    except FileNotFoundError:
        print(f"The file '{original_path}' does not exist.")
    except Exception as e:
        print(f"An error occurred: {e}")

def overwrite_variable(filename, variable, value):
    """
    Replace a specified variable with the given value in a file within the modified directory.
    The value can be a number or a string.
    """
    modified_path = os.path.join(modified_directory, filename)

    try:
        with open(modified_path, 'r') as file:
            content = file.read()

        # Check if value is nan (using numpy's isnan function) and replace with '-'
        if isinstance(value, float) and np.isnan(value):
            replacement = '-'
        else:
            replacement = str(value)

        content = content.replace(variable, replacement)

        with open(modified_path, 'w') as file:
            file.write(content)

        print(f"Replaced '{variable}' with '{replacement}' in '{modified_path}'.")
    except Exception as e:
        print(f"An error occurred: {e}")


# Function to safely round values
def safe_round(value, decimals):
    if isinstance(value, float):
        return round(value, decimals)
    return value

#power balance

#MCF
PNRL = 2600  # Fusion Power
PALPHA = PNRL * 3.52 / 17.58  # Charged particle power
PNEUTRON = PNRL - PALPHA  # Neutron power
MN = 1.1  # Neutron energy multiplier
ETAP = 0.5  # Pumping power capture efficiency
FPCPPF = 0.06  # Primary Coolant Pumping Power Fraction
FSUB = 0.03  # Subsystem and Control Fraction
PTRIT = 10.00  # Tritium Systems
PHOUSE = 4.00  # Housekeeping power
PTFCOOL = 12.7  # Solenoid coil cooling
PPFCOOL = 11  # Mirror coil cooling
PCOOL=PPFCOOL+PTFCOOL
PTF =  1 # Power into TF coils
PPF = 1  # Power into PF (equilibrium) coils how to handle for HTS??
ETAPIN = 0.5  # Input power wall plug efficiency
ETATH = 0.5  # Thermal conversion efficiency
ETADE  = 0.85 #Direct energy conversion efficiency
PCRYO = 0.5
PINPUT = 50  # Input power

# Calculate dependent values
PAUX = PTRIT + PHOUSE
PCOILS = PTF + PPF
PTH = MN * PNEUTRON  + PINPUT + ETATH * (FPCPPF * ETAP + FSUB) * (MN * PNEUTRON)
PTHE = ETATH*PTH #Total thermal electric power
PDEE = ETADE*PALPHA
PET = PDEE+PTHE #Gross electric
PLOSS = PTH - PTHE-PDEE
PPUMP = FPCPPF * PTHE
PSUB = FSUB * PTHE
QSCI =  PNRL/ PINPUT
QENG = (ETATH * (MN * PNEUTRON + PPUMP + PINPUT)+ETADE*PALPHA) / (PCOILS + PPUMP + PSUB + PAUX + PCOOL+PCRYO + PINPUT / ETAPIN)
REFRAC = 1 / QENG
PNET = (1 - 1 / QENG) * PET


PT_dict = {
    'PNRL': PNRL, 'PALPHA': PALPHA, 'PNEUTRON': PNEUTRON, 'MN': MN, 'ETAPIN': ETAPIN,
    'FPCPPF': FPCPPF, 'FSUB': FSUB, 'PTRIT': PTRIT, 'PHOUSE': PHOUSE, 'PTFCOOL': PTFCOOL, 'PPFCOOL': PPFCOOL,'PCOOL': PCOOL,
    'PINPUT': PINPUT, 'PTF': PTF, 'PPF': PPF, 'ETAP': ETAP, 'ETATH': ETATH, 'PAUX': PAUX,
    'PCRYO': PCRYO, 'PCOILS': PCOILS,'PTHE':PTHE, 'ETADE':ETADE, 'PDEE':PDEE, 'PTH': PTH, 'PET': PET, 'PLOSS': PLOSS, 'PPUMP': PPUMP,
    'PSUB': PSUB, 'QSCI': QSCI, 'QENG': QENG, 'REFRAC': REFRAC, 'PNET': PNET, 'REFRAC':REFRAC
}

# Loop through the dictionary and overwrite each variable
copy_file('powerTableMFEDT.tex')
for var_name, var_value in PT_dict.items():
    overwrite_variable('powerTableMFEDT.tex', var_name, round(var_value,1))

#Cost Category 10: Pre-construction Costs

#Cost Category 11: Land and Land Rights

C110000 = np.sqrt(NMOD) * (PNEUTRON /239 * 0.9 + PNRL/239*0.9)

#Cost Category 12 – Site Permits

C120000 = 10

#Cost Category 13 – Plant Licensing
# https://world-nuclear.org/information-library/economic-aspects/economics-of-nuclear-power.aspx

C130000 = 200

#Cost Category 14 – Plant Permits

C140000 = 5

#Cost Category 15 – Plant Studies

C150000 = 5

#Cost Category 16 – Plant Reports

C160000 = 2

#Cost Category 17 – Other Pre-Construction Costs

C170000 = 1

#Cost Cetegory 19 - Contingency

C190000 = 0.1 * (C110000 + C120000 + C130000 + C140000 + C150000 + C160000 + C170000)
C190000=0
#Cost Category 10

C100000 = C110000 + C120000 + C130000 + C140000 + C150000 + C160000 + C170000

copy_file('CAS100000.tex')
overwrite_variable('CAS100000.tex', 'Nmod', NMOD)
overwrite_variable('CAS100000.tex', 'C100000', round(C100000))
overwrite_variable('CAS100000.tex', 'C110000', round(C110000))
overwrite_variable('CAS100000.tex', 'C120000', round(C120000))
overwrite_variable('CAS100000.tex', 'C130000', round(C130000))
overwrite_variable('CAS100000.tex', 'C140000', round(C140000))
overwrite_variable('CAS100000.tex', 'C150000', round(C150000))
overwrite_variable('CAS100000.tex', 'C160000', round(C160000))
overwrite_variable('CAS100000.tex', 'C170000', round(C170000))
overwrite_variable('CAS100000.tex', 'C190000', round(C190000))

#Cost Category 21: Buildings

#Buildings come out to be 470$/kW gross, so if we are looking at a gross power of 1GW, we have:


#21.01.00,,Site improvements and facs,,20.7,,,,,2019,1.19,

C210100 = 24.6/1e3 * PET

#21.02.00,,Fusion Heat Island Building,Concrete & Steel,131.6,48.3,48.3,60,140000,2009,1.42,

C210200 = 186.8/1e3 * PET

#21.03.00,,Turbine building,Steel ,45.3,48.3,48.3,30,70000,2019,1.19,

C210300 = 54.0/1e3 * PET

#21.04.00,,Heat exchanger building,Concrete & Steel,31.7,48.3,48.3,15,35000,2019,1.19,

C210400 = 37.8/1e3 * PET

#21.05.00,,Power supply & energy storage,Concrete & Steel,9.1,9.7,9.7,6.0,560,2019,1.19,

C210500 = 10.8/1e3 * PET
#21.06.00,,Reactor auxiliaries,Concrete & Steel,4.5,4.8,4.8,3.0,70,2019,1.19,

C210600 = 5.4/1e3 * PET

#21.07.00,,Hot cell,Concrete & Steel,65.8,24.2,24.2,60,35000,2013,1.42,

C210700 = 93.4/1e3 * PET

#21.08.00,,Reactor services,Steel frame,13.2,4.8,4.8,10,233,2013,1.42,

C210800 = 18.7/1e3 * PET

#21.09.00,,Service water,Steel frame,0.2,1.3,4.0,4.0,21,2019,1.19,

C210900 = 0.3/1e3 * PET

#21.10.00,,Fuel storage,Steel frame,0.9,5.0,15.0,2.5,188,2019,1.19,

C211000 = 1.1/1e3 * PET

#21.11.00,,Control room,Steel frame,0.7,4.0,12.0,2,96,2019,1.19,

C211100 = 0.9/1e3 * PET

#21.12.00,,Onsite AC power,Steel frame,0.7,3.6,10.8,1.8,70,2019,1.19,

C211200 = 0.8/1e3 * PET

#21.13.00,,Administration,Steel frame,3.7,20.0,60.0,10,12000,2019,1.19,

C211300 = 4.4/1e3 * PET

#21.14.00,,Site services,Steel frame,1.3,7.3,22.0,3.7,593,2019,1.19,

C211400 = 1.6/1e3 * PET

#21.15.00,,Cryogenics,Steel frame,2.0,11.0,33.0,5.5,2003,2019,1.19,

C211500 = 2.4/1e3 * PET

#21.16.00,,Security,Steel frame,0.7,4.0,12.0,2,96,2019,1.19,

C211600 = 0.9/1e3 * PET

#21.17.00,,Ventilation stack,Steel cylinder & concrete foundation,22.7,,,120,,2019,1.19,

C211700 = 27.0/1e3 * PET

C210000 = C210100 + C210200 + C210300 + C210400 + C210500 + C210600 + C210700 + C210800 + C210900 + C211000 + C211100 + C211200 + C211300 + C211400 + C211500 + C211600 + C211700

C211900 = 0.1*C210000 #10% contingency
C211900 =0

C210000 = C210000+C211900

copy_file('CAS210000.tex')
overwrite_variable('CAS210000.tex', 'C210000', round(C210000))
overwrite_variable('CAS210000.tex', 'C210100', round(C210100))
overwrite_variable('CAS210000.tex', 'C210200', round(C210200))
overwrite_variable('CAS210000.tex', 'C210300', round(C210300))
overwrite_variable('CAS210000.tex', 'C210400', round(C210400))
overwrite_variable('CAS210000.tex', 'C210500', round(C210500))
overwrite_variable('CAS210000.tex', 'C210600', round(C210600))
overwrite_variable('CAS210000.tex', 'C210700', round(C210700))
overwrite_variable('CAS210000.tex', 'C210800', round(C210800))
overwrite_variable('CAS210000.tex', 'C210900', round(C210900))
overwrite_variable('CAS210000.tex', 'C210000', round(C210000))
overwrite_variable('CAS210000.tex', 'C211000', round(C211000))
overwrite_variable('CAS210000.tex', 'C211100', round(C211100))
overwrite_variable('CAS210000.tex', 'C211200', round(C211200))
overwrite_variable('CAS210000.tex', 'C211300', round(C211300))
overwrite_variable('CAS210000.tex', 'C211400', round(C211400))
overwrite_variable('CAS210000.tex', 'C211500', round(C211500))
overwrite_variable('CAS210000.tex', 'C211600', round(C211600))
overwrite_variable('CAS210000.tex', 'C211700', round(C211700))
overwrite_variable('CAS210000.tex', 'C211900', round(C211900))

#Cost Category 22.1.1: Reactor Equipment

"""
CALCS
"""

# Radial build inputs
axis_t = 4.75
plasma_t = 0.45
vacuum_t = 0.1
firstwall_t = 0.1
blanket1_t = 0.6
reflector_t = 0.2
ht_shield_t = 0.5
structure_t = 0.2
gap1_t = 0.5
vessel_t = 0.2
coil_t = 0.05
gap2_t = 0.5
lt_shield_t = 0.3
bioshield_t = 1

# Inner radii
axis_ir = axis_t
plasma_ir = axis_ir
vacuum_ir = plasma_t + plasma_ir
firstwall_ir = vacuum_t + vacuum_ir
blanket1_ir = firstwall_ir + firstwall_t
reflector_ir = blanket1_ir + blanket1_t
ht_shield_ir = reflector_ir + reflector_t
structure_ir = ht_shield_ir + ht_shield_t
gap1_ir = structure_ir + structure_t
vessel_ir = gap1_ir + gap1_t
lt_shield_ir = vessel_ir + vessel_t  # Moved lt_shield here
coil_ir = lt_shield_ir + lt_shield_t  # Updated coil_ir calculation
gap2_ir = coil_ir + coil_t
bioshield_ir = gap2_ir + gap2_t  # Updated bioshield inner radius

# Outer radii
axis_or = axis_ir + axis_t
plasma_or = plasma_ir + plasma_t
vacuum_or = vacuum_ir + vacuum_t
firstwall_or = firstwall_ir + firstwall_t
blanket1_or = blanket1_ir + blanket1_t
reflector_or = reflector_ir + reflector_t
ht_shield_or = ht_shield_ir + ht_shield_t
structure_or = structure_ir + structure_t
gap1_or = gap1_ir + gap1_t
vessel_or = vessel_ir + vessel_t
lt_shield_or = lt_shield_ir + lt_shield_t  # Moved lt_shield here
coil_or = coil_ir + coil_t  # Updated coil_or calculation
gap2_or = gap2_ir + gap2_t
bioshield_or = bioshield_ir + bioshield_t  # Updated bioshield outer radius

# Volumes for sphere
def calc_volume(inner, outer):
    return 4/3* np.pi * (outer**3 - inner**3)

axis_vol = calc_volume(axis_ir, axis_or)
plasma_vol = calc_volume(plasma_ir, plasma_or)
vacuum_vol = calc_volume(vacuum_ir, vacuum_or)
firstwall_vol = calc_volume(firstwall_ir, firstwall_or)
blanket1_vol = calc_volume(blanket1_ir, blanket1_or)
reflector_vol = calc_volume(reflector_ir, reflector_or)
ht_shield_vol = calc_volume(ht_shield_ir, ht_shield_or)
structure_vol = calc_volume(structure_ir, structure_or)
gap1_vol = calc_volume(gap1_ir, gap1_or)
vessel_vol = calc_volume(vessel_ir, vessel_or)
lt_shield_vol = calc_volume(lt_shield_ir, lt_shield_or)  # Moved lt_shield volume here
coil_vol = calc_volume(coil_ir, coil_or)*(9*0.779)/40  # Updated coil volume calculation
gap2_vol = calc_volume(gap2_ir, gap2_or)
bioshield_vol = calc_volume(bioshield_ir, bioshield_or)  # Updated bioshield volume


#Cost calc 1

# Define the values
f_W = 1
C_OFW = firstwall_vol*materials["W"]["rho"]*materials["W"]["c_raw"]*materials["W"]["m"]
M_OFW = 0
# Blanket is rotating vortex of PbLi
FPCPPFbLi = 0.9
f_FS = 0.1
# Cost of blanket
C_OBI_PbLi = blanket1_vol * (materials["PbLi"]["rho"] * materials["PbLi"]["c"] * FPCPPFbLi)
C_OBI_FS = blanket1_vol * (materials["FS"]["rho"] * materials["FS"]["c_raw"] * f_FS)
# Total heat capacity of OBI
C_OBI = C_OBI_FS + C_OBI_PbLi
# Calculate C_22_1_1
C220101 = AM * NMOD * (C_OFW + C_OBI) / 1e6 *10 # First Wall/Blanket/reflector

"""
PLOTTING RADIAL BUILD
"""

## The names of the sections
# Updated order of the sections
sections = ['Vacuum', 'First Wall', 'Blanket', 'Reflector', 'HT Shield', 'Structure', 'Gap', 'Vessel', 'LT Shield', 'Coil', 'Gap', 'Bioshield']

# The thickness of each section (for stacked bar plot)
thickness = [vacuum_t, firstwall_t, blanket1_t, reflector_t, ht_shield_t, structure_t, gap1_t, vessel_t, lt_shield_t, coil_t, gap2_t, bioshield_t]

# Updated colors for each section
colors = ['black', 'lightblue', 'darkblue', 'blue', 'cornflowerblue', 'coral', 'lightgray', 'orange', 'slateblue', 'green', 'lightgray', 'darkorange']

# Plotting the stacked bar graph
fig, ax = plt.subplots(figsize=(18, 3.5)) # Adjust the figsize to get the desired aspect ratio

# Adding each section to the bar plot
left = 0  # Initialize left at 0
for i, (section, thk) in enumerate(zip(sections, thickness)):
    ax.barh('Thickness', thk, left=left, color=colors[i], edgecolor='white', label=section)
    left += thk  # Increment left by the thickness of the current section

# Setting labels and title
ax.set_xlabel('Radius (m)')

# Creating the legend
ax.legend(bbox_to_anchor=(1.05, 1), loc='upper left')

# Show grid for the x-axis
ax.xaxis.grid(True)

# Show the plot
plt.tight_layout()
plt.show()

# Export as pdf
fig.savefig(os.path.join(figures_directory, 'radial_build.pdf'), bbox_inches='tight')


#Template hydration
output_values = {
    'TH14': (bioshield_t, 1), 'RAD14I': (bioshield_ir, 1), 'RAD14O': (bioshield_or, 1), 'VOL14': (bioshield_vol, 1),
    'TH13': (gap2_t, 1), 'RAD13I': (gap2_or, 1), 'RAD13O': (gap2_or, 1), 'VOL13': (gap2_vol, 1),
    'TH12': (lt_shield_t, 1), 'RAD12I': (lt_shield_or, 1), 'RAD12O': (lt_shield_or, 1), 'VOL12': (lt_shield_vol, 1),
    'TH11': (coil_t, 1), 'RAD11I': (coil_ir, 1), 'RAD11O': (coil_or, 1), 'VOL11': (coil_vol, 1),
    'TH10': (lt_shield_t, 1), 'RAD10I': (lt_shield_or, 1), 'RAD10O': (lt_shield_or, 1), 'VOL10': (lt_shield_vol, 1),
    'TH9': (ht_shield_t, 1), 'RAD9I': (ht_shield_or, 1), 'RAD9O': (ht_shield_or, 1), 'VOL9': (ht_shield_vol, 1),
    'TH8': (vessel_t, 1), 'RAD8I': (vessel_or, 1), 'RAD8O': (vessel_or, 1), 'VOL8': (vessel_vol, 1),
    'TH7': (gap1_t, 1), 'RAD7I': (gap1_or, 1), 'RAD7O': (gap1_or, 1), 'VOL7': (gap1_vol, 1),
    'TH6': (reflector_t, 1), 'RAD6I': (reflector_or, 1), 'RAD6O': (reflector_or, 1), 'VOL6': (reflector_vol, 1),
    'TH5': (structure_t, 1), 'RAD5I': (structure_or, 1), 'RAD5O': (structure_or, 1), 'VOL5': (structure_vol, 1),
    'TH4': (blanket1_t, 1), 'RAD4I': (blanket1_or, 1), 'RAD4O': (blanket1_or, 1), 'VOL4': (blanket1_vol, 1),
    'TH3': (firstwall_t, 1), 'RAD3I': (firstwall_or, 1), 'RAD3O': (firstwall_or, 1), 'VOL3': (firstwall_vol, 1),
    'TH2': (vacuum_t, 1), 'RAD2I': (vacuum_or, 1), 'RAD2O': (vacuum_or, 1), 'VOL2': (vacuum_vol, 1),
    'TH1': (plasma_t, 1), 'RAD1I': (plasma_or, 1), 'RAD1O': (plasma_or, 1), 'VOL1': (plasma_vol, 1),
    'primaryC': primaryC, 'secondaryC': secondaryC, 'neutronM': neutronM,
    'structure1': structure1, 'firstW': firstW
}


# Copying the .tex file
copy_file('CAS220101_MFE_DT.tex')
# Overwriting the placeholders in the .tex file
for var_name, var_value in output_values.items():
    if isinstance(var_value, tuple):
        overwrite_variable('CAS220101_MFE_DT.tex', var_name, round(var_value[0], var_value[1]))

#Cost Category 22.1.2: Shield

"""
CALCS
"""
# Define the fractions
f_SiC = 0.00
FPCPPFbLi = 0.1
f_W = 0.00
f_BFS = 0.9

# Retrieve the volume of HTS from the reactor_volumes dictionary
#V_HTS = volumes["V_HTS"]
V_HTS = round(ht_shield_vol,1)

# Calculate the cost for HTS
C_HTS = round(V_HTS * (
    materials["SiC"]["rho"] * materials["SiC"]["c_raw"] * materials["SiC"]["m"] * f_SiC +
    materials["PbLi"]["rho"] * materials["PbLi"]["c"] * FPCPPFbLi +
    materials["W"]["rho"] * materials["W"]["c_raw"] * materials["W"]["m"] * f_W +
    materials["BFS"]["rho"] * materials["BFS"]["c_raw"] * materials["BFS"]["m"] * f_BFS
) / 1e6,1)

# Volume of HTShield that is BFS
V_HTS_BFS = V_HTS * f_BFS
# The cost C_22_1_2 is the same as C_HTS
C22010201 = round(C_HTS,1)*5
C22010202 = lt_shield_vol*materials["SS316"]["c_raw"]*materials["SS316"]["m"]/1e3
C22010203 = bioshield_vol*materials["SS316"]["c_raw"]*materials["SS316"]["m"]/1e3
C22010204 = C22010203*0.1
C220102 = C22010201+C22010202+C22010203+C22010204


copy_file('CAS220102.tex')
overwrite_variable('CAS220102.tex', 'C22010201', round(C22010201))
overwrite_variable('CAS220102.tex', 'C22010202', round(C22010202))
overwrite_variable('CAS220102.tex', 'C22010203', round(C22010203))
overwrite_variable('CAS220102.tex', 'C22010204', round(C22010204))
overwrite_variable('CAS220102.tex', 'C220102', round(C220102))

overwrite_variable('CAS220102.tex', 'V220102', round(V_HTS))
overwrite_variable('CAS220102.tex', 'primaryC', primaryC)
overwrite_variable('CAS220102.tex', 'VOL9', round(ht_shield_vol))
overwrite_variable('CAS220102.tex', 'VOL11', round(lt_shield_vol))

#Cost Category 22.1.3: Coils
import math
from scipy.interpolate import LinearNDInterpolator
from sklearn.linear_model import LinearRegression

#Extrapolated data from Yuhu
# Reconstructing the DataFrame for the provided data after code state reset

yuhudata = {
    "R_Turns": [31]*6 + [44]*6 + [54]*6 + [63]*6 + [70]*6 + [77]*6 + [83]*6 + [89]*6 + [94]*6,
    "Z_Turns": [31]*6 + [44]*6 + [54]*6 + [63]*6 + [70]*6 + [77]*6 + [83]*6 + [89]*6 + [94]*6,
    "Single cable I (A)": [6995.627628] * 54,
    "r_av(m)": [2, 4, 6, 8, 10, 12] * 9,
    "z_av(m)": [0] * 54,
    "dr(m)": [0.49]*6 + [0.69]*6 + [0.84]*6 + [0.98]*6 + [1.09]*6 + [1.19]*6 + [1.29]*6 + [1.38]*6 + [1.46]*6,
    "dz(m)": [0.49]*6 + [0.69]*6 + [0.84]*6 + [0.98]*6 + [1.09]*6 + [1.19]*6 + [1.29]*6 + [1.38]*6 + [1.46]*6,
    "B_mag": [2.10616637, 1.055303175, 0.7038001463, 0.5279190692, 0.4223607165, 0.3519787731,
              4.231018337, 2.124598537, 1.417450588, 1.063360003, 0.8507881835,1.067875207,
              6.354170539, 3.198019278, 2.134370652, 1.601384033, 1.281329818, 1.067875207,
              8.619030499, 4.349716057, 2.904216973, 2.179287368, 1.743841805, 1.453386963,
              10.60629681, 5.36649644, 3.584455229, 2.690064162, 2.152680752, 1.794183669,
              12.79002712, 6.48913364, 4.335975808, 3.254475088, 2.604488795, 2.170815472,
              14.80337025, 7.534262639, 5.036490264, 3.780787985, 3.025873763, 2.522119182,
              16.95437589, 8.656634754, 5.789240305, 4.34645187, 3.478801173, 2.899735523,
              18.84016525, 9.649873196, 6.456142837, 4.84777952, 3.880275834, 3.234481465]
}

# Creating DataFrame
df_new = pd.DataFrame(yuhudata)
# Extracting necessary columns for interpolation
interp_data = df_new[['B_mag', 'r_av(m)', 'R_Turns', 'Z_Turns', 'Single cable I (A)', 'dr(m)', 'dz(m)']]

# Preparing the interpolators for each output variable
rTurnsCICC_interp = LinearNDInterpolator(interp_data[['B_mag', 'r_av(m)']].values, interp_data['R_Turns'])
zTurnsCICC_interp = LinearNDInterpolator(interp_data[['B_mag', 'r_av(m)']].values, interp_data['Z_Turns'])
cableCurrentCICC_interp = LinearNDInterpolator(interp_data[['B_mag', 'r_av(m)']].values, interp_data['Single cable I (A)'])
drCICC_interp = LinearNDInterpolator(interp_data[['B_mag', 'r_av(m)']].values, interp_data['dr(m)'])
dzCICC_interp = LinearNDInterpolator(interp_data[['B_mag', 'r_av(m)']].values, interp_data['dz(m)'])
print("HERE", rTurnsCICC_interp)
print("HERE", cableCurrentCICC_interp)
# Function to fit linear regression model for extrapolation
def fit_linear_regression(X, y):
    model = LinearRegression()
    model.fit(X, y)
    return model

# Fitting models
X = interp_data[['B_mag', 'r_av(m)']].values
models = {
    'R_Turns': fit_linear_regression(X, interp_data['R_Turns']),
    'Z_Turns': fit_linear_regression(X, interp_data['Z_Turns']),
    'Single cable I (A)': fit_linear_regression(X, interp_data['Single cable I (A)']),
    'dr(m)': fit_linear_regression(X, interp_data['dr(m)']),
    'dz(m)': fit_linear_regression(X, interp_data['dz(m)']),
}

# Function to interpolate or extrapolate
def interpolate_or_extrapolate(model_interp, model_regr, X_new):
    # Try to interpolate
    interp_val = model_interp(X_new)
    if not np.isnan(interp_val):
        return interp_val
    else:
        # Extrapolate if interpolation is not possible
        return model_regr.predict(X_new)[0]



def magnetsAll(cableW, cableH, tapeW, tapeT, mCostYBCO, mCostSS, mCostCu,
               cuDensity, ssDensity, fracCsCuYuhu, fracCsSsYuhu, dr,dz,
               rCentre, zCentre, noCoils, mfrFactor, magnetType,fracIns):
    jTape = 0
    if magnetType == "HTS CICC":

      jTape = 150 #critical current density of YBCO at 18T

      useyuhuextrap = input("Use predefined extrapolation? (enter y for yes, n for no)")

      if useyuhuextrap.lower() in ["y", "yes"]:
        rspec= input("Please enter, in metres, the required average radius for your HTS CICC coil")
        Bspec= input("Please enter, in Tesla, the required field at r=0 for your HTS CICC coil")

        # Interpolated values
        X_new = np.array([[float(Bspec), float(rspec)]])
        rTurns = interpolate_or_extrapolate(rTurnsCICC_interp, models['R_Turns'], X_new )
        zTurns = interpolate_or_extrapolate(zTurnsCICC_interp, models['R_Turns'], X_new )
        cableCurrent = float(interpolate_or_extrapolate(cableCurrentCICC_interp, models['R_Turns'], X_new ))
        dr = interpolate_or_extrapolate(drCICC_interp, models['R_Turns'], X_new )
        dz = interpolate_or_extrapolate(dzCICC_interp, models['R_Turns'], X_new )

        turnsScTot = rTurns*zTurns

        csArea = dr*dz
        turnsC = csArea / (cableW * cableH)
        turnsScS = turnsScTot/turnsC #Turns of REBCO in each cable
        currentSupply = turnsC*cableCurrent

        volCoil = csArea*2*np.pi*rCentre
        tapeLength = turnsScTot * rCentre * 2 * math.pi / 1e3
        maxTapeCurrent = cableCurrent/turnsScS

        costSC = maxTapeCurrent / 1e3 * tapeLength * 1e3 * mCostYBCO / 1e6
        costCu = fracCsCuYuhu * mCostCu * volCoil * cuDensity / 1e6
        costSS = fracCsSsYuhu * mCostSS * volCoil * ssDensity / 1e6
        costI = np.nan
        totMatCost = costSC + costCu + costSS
        magCost = totMatCost * mfrFactor

      elif useyuhuextrap.lower() in ["n", "no"]:

        maxTapeCurrent = jTape * tapeW *1e3 *tapeT *1e3 # Current in A
        turnsScS = (cableW * cableH*fracCsScYuhu) / (tapeW * tapeT)
        cableCurrent = maxTapeCurrent * turnsScS

        csArea = dr*dz
        turnsC = csArea / (cableW * cableH)
        currentSupply = cableCurrent * turnsC
        volCoil = csArea*2*np.pi*rCentre

        turnsScTot = turnsScS * turnsC
        tapeLength = turnsScTot * rCentre * 2 * math.pi / 1e3

        costSC = maxTapeCurrent / 1e3 * tapeLength * 1e3 * mCostYBCO / 1e6
        costCu = fracCsCuYuhu * mCostCu * volCoil * cuDensity / 1e6
        costSS = fracCsSsYuhu * mCostSS * volCoil * ssDensity / 1e6
        costI = np.nan
        totMatCost = costSC + costCu + costSS
        magCost = totMatCost * mfrFactor

    elif magnetType == "HTS Pancake":

      jTape = 150 #critical current density of YBCO at 18T

      cableW = np.nan  # Cables are not used here
      cableH = np.nan  # Cables are not used here

      maxTapeCurrent = jTape * tapeW *1e3 *tapeT *1e3 # Current in A
      csArea = dr*dz
      turnsScS =  (1-fracIns)*csArea / (tapeW * tapeT)
      cableCurrent = maxTapeCurrent * turnsScS #In this case the 'cable' is the entire winding
      volCoil = csArea*2*np.pi*rCentre
      turnsC = np.nan
      turnsScTot = turnsScS
      currentSupply = cableCurrent

      turnsI = fracIns*csArea / (tapeW * tapeT) #turns of (partial?) insulation
      noP = turnsScS/turnsP #number of pancakes based on total required turns and the number of turns in a reference pancake coil

      volI = turnsScS * rCentre * 2 * math.pi/1e3*fracIns*(tapeW * tapeT) #total volume of insulation [m^3]
      tapeLength = turnsScS * rCentre * 2 * math.pi / 1e3

      costSC = maxTapeCurrent / 1e3 * tapeLength * 1e3 * mCostYBCO / 1e6
      costI = mcostI * volI * Idensity/1e6  # material cost of inter-tape insulation [m$]
      costCu = 0
      costSS = 0
      totMatCost = costSC + costCu + costSS + costI
      magCost = totMatCost * mfrFactor

    elif magnetType == "Copper":

      jTape = maxCuCurrent/(0.5*cuWireD*1e3)**2

      cableW = np.nan  # Cables are not used here
      cableH = np.nan  # Cables are not used here

      #In this case 'Tape' refers to copper wire AWG 11
      csArea = dr*dz

      turnsScS = (1-fracIns)*csArea / (0.5*cuWireD)**2
      turnsI = fracIns*csArea / (0.5*cuWireD)**2 #turns of (partial?) insulation

      volCoil = csArea*2*np.pi*rCentre
      cuWireCurrent = maxTapeCurrent = maxCuCurrent #current through each cu_wire [A]
      turnsScTot=  turnsScS
      turnsC = np.nan
      cableCurrent = np.nan
      tapeLength = turnsScS * rCentre * 2 * math.pi / 1e3
      currentSupply = cuWireCurrent*turnsScS #Total supply current [A]

      volI = fracIns*csArea*rCentre*2*np.pi #total volume of insulation [m^3]

      costSC = 0
      costCu = (volCoil - volI)*cuDensity*mCostCu/1e6 #[$] simple volumetric material calc
      costI = mcostI * volI * Idensity/1e6  # material cost of inter-turn insulation [m$]
      costSS = 0
      totMatCost = costSC + costCu + costSS +costI
      magCost = totMatCost * mfrFactor

    else:
      print("ERROR: Enter valid magnet type.")


    return {
        'volCoil': volCoil,
        'csArea': csArea,
        'turnsC': turnsC,
        'cableCurrent': cableCurrent,
        'currentSupply': np.round(currentSupply,3)*1e-6,
        'turnsScTot': np.round(turnsScTot,1),
        'tapeLength': tapeLength,
        'tapeCurrent': maxTapeCurrent,
        'costSC': costSC,
        'costCu': costCu,
        'costSS': costSS,
        'costI':costI,
        'totMatCost': totMatCost,
        'magCost': magCost,
        'dr':dr,
        'dz':dz,
        'magnetType':magnetType,
        'fracIns':fracIns,
        'mfrFactor':mfrFactor,
        'jTape':jTape,
        'cableH':cableH,
        'cableW':cableW

    }

# Constants
cableW = 0.014  # Cable width in meters
cableH = 0.017  # Cable height in meters
tapeW = 0.004  # Tape width in meters
tapeT = 0.00013  # Tape thickness in meters
jTape = 0
 # Current density of the tape in A/mm^2

mCostYBCO = 10  # Material cost of YBCO tape in $/kAm
mCostSS = 5  # Material cost of stainless steel in $/kg
mCostCu = 10.3  # Material cost of copper in $/kg
cuDensity = 7900  # Density of copper in kg/m^3
ssDensity = 7900  # Density of stainless steel in kg/m^3

fracCsCuYuhu = 0.307  # Fractional cross-sectional area of copper in Yuhu Zhai's cable design
fracCsSsYuhu = 0.257  # Fractional cross-sectional area of stainless steel in Yuhu Zhai's cable design
fracCsScYuhu = 0.257 # Fractional cross-sectional area of REBCO in Yuhu Zhai's cable design
totCsAreaYuhu = 0.000238  # Total cross-sectional area of Yuhu Zhai's cable design in m^2

#PANCAKE
mcostI = 20 # Material cost of insulator in $/kg
Idensity = 3000  # Density of insulator in kg/m^3
turnsP = 18 #Turns of REBCO tape per pancake
maxCuCurrent = 75 # [A] max current for water cooled AWG 11
cuWireD= 3.3e-3  # copper wire diameter in meters AWG8

# Inputs for the magnets
"""Note that for HTS CICC, the user will be presented with the option of using extrapolation from Yuhu Zhai's 2016 cable geometry,
   in which case the input values for that coil will be overwritten"""

magnetNames=["TF","CS", "PF1","PF2","PF3","PF4","PF5","PF6","PF7","PF8"]
magnetCoilCounts = [12,1,2,2,2,2,2,2,2,2]
magnetType = ["HTS CICC","HTS CICC","HTS CICC","HTS CICC","HTS CICC","HTS CICC","HTS CICC","HTS CICC","HTS CICC","HTS CICC"]
rCentreList = [(coil_ir-axis_ir), 0.18, 0.67, 0.9,1.28,2.72,5.3,9.34,9.34,9.34]
zCentreList = [0,0, 3.73,4.64,5.55,7.24,7.24,5,3.6,2.2]
dr = [0.25,0.2, 0.3, 0.3,0.5,0.75,1.8,1,1,1]
dz = [0.35,6.3, 0.6, 0.6,0.6,0.37,0.37,1,1,1]
fracIns = [0,0,0,0,0,0,0,0,0,0]
mfrFactor =[3,3,3,3,3,3,3,3,3,3] #Manufacturing factor for each coil
structFactor = 1 # Structural multiplication factor
#FOR TOKAMAKS: TF, then CS, then PF coils

# Calculate magnet properties and costs for each magnet
magnetCosts = []
allMagnetProperties = {}
for i in range(len(magnetNames)):
    magnetProperties = magnetsAll(cableW, cableH, tapeW, tapeT, mCostYBCO, mCostSS, mCostCu,
                                  cuDensity, ssDensity, fracCsCuYuhu, fracCsSsYuhu, dr[i], dz[i],
                                  rCentreList[i], zCentreList[i],
                                  magnetCoilCounts[i], mfrFactor[i], magnetType[i],fracIns[i])
    allMagnetProperties.update({f'magnet{i+1}{k}': v for k, v in magnetProperties.items()})
    magnetCosts.append(magnetProperties['magCost'])

# Additional calculations based on magnetCosts

# Additional calculations based on magnetCosts
magnetStructCosts = []
for i in range(len(magnetCoilCounts)):
    magnetStructCosts.append(structFactor * magnetCosts[i])

totStructCost = sum(magnetStructCosts)

magnetTotalCostsIndividual = [cost + structCost for cost, structCost in zip(magnetCosts, magnetStructCosts)]
magnetTotalCosts = [totalCost * coilCount for totalCost, coilCount in zip(magnetTotalCostsIndividual, magnetCoilCounts)]

nopfcoils =sum(magnetCoilCounts[2:])
nopfpairs =nopfcoils/2

C22010301 = magnetTotalCosts[0]  #Solenoid coils
C22010302 = magnetTotalCosts[1]  #First mirror coil
C22010303 = magnetTotalCosts[2] # Second mirror coil
C22010304 = 0.05 * (C22010301 + C22010302+C22010303)  # Shim coil costs, taken as 5% total primary magnet costs
C22010305 = totStructCost  # Structural cost
C220103 = C22010301 + C22010302 + C22010303  +C22010304  + C22010305  # Total cost

# Gathering all variables in a dictionary
variablesToOverwrite = {
    'cableW': cableW, 'cableH': cableH, 'tapeW': tapeW, 'tapeT': tapeT, 'jTape': jTape,
    'mCostYBCO': mCostYBCO, 'mCostSS': mCostSS, 'mCostCu': mCostCu,
    'cuDensity': cuDensity, 'ssDensity': ssDensity,
    'fracCsCuYuhu': fracCsCuYuhu, 'fracCsSsYuhu': fracCsSsYuhu,
    'structFactor': structFactor,'C22010301': C22010301, 'C22010302': C22010302,
    'C22010303': C22010303, 'C220103': C220103, 'C22010304': C22010304,'C22010305': C22010305, 'mcostI':mcostI, 'nopfcoils':nopfcoils,'nopfpairs':nopfpairs
}
# Loop and add the magnet properties
for i, (magnetName, magnetCoilCount) in enumerate(zip(magnetNames, magnetCoilCounts)):
    variablesToOverwrite[f'no{magnetName}Coils'] = magnetCoilCount
    variablesToOverwrite[f'{magnetName}StructCost'] = magnetStructCosts[i]
    variablesToOverwrite[f'{magnetName}MagCost'] = magnetCosts[i]
    variablesToOverwrite[f'total{magnetName}CostI'] = magnetTotalCostsIndividual[i]
    variablesToOverwrite[f'total{magnetName}Cost'] = magnetTotalCosts[i]

# Add calculated magnet properties with suffixes
for i in range(len(magnetNames)):
    magnetProperties = magnetsAll(cableW, cableH, tapeW, tapeT, mCostYBCO, mCostSS, mCostCu,
                                  cuDensity, ssDensity, fracCsCuYuhu, fracCsSsYuhu,
                                  dr[i],dz[i], rCentreList[i], zCentreList[i],
                                  magnetCoilCounts[i], mfrFactor[i], magnetType[i],fracIns[i])
    for key, value in magnetProperties.items():
        variablesToOverwrite[f"{key}{i+1}"] = value

# Overwrite each variable in the .tex file
copy_file('CAS220103_MIF_DT_mirror.tex')
for varName, varValue in variablesToOverwrite.items():
    overwrite_variable('CAS220103_MIF_DT_mirror.tex', varName, safe_round(varValue,1))

"""
Overwriting input lists
"""

def generateVariableNames(listName, listValues):
    return {f"{listName}{i+1}": value for i, value in enumerate(listValues)}

def updateLatexValues(*lists):
    for listName, listValues in lists:
        varsToUpdate = generateVariableNames(listName, listValues)
        for varName, varValue in varsToUpdate.items():
            overwrite_variable('CAS220103_MIF_DT_mirror.tex', varName, varValue)

# Updating the LaTeX document with new values
updateLatexValues(
    ("rCentre", rCentreList),
    ("zCentre", zCentreList) )

#22.1.4 Supplementary heating

heating_refs = {
    "ARIES-AT": {"Type": "ICRF/LH", "Power (MW)": 37.441, "$/W (2009)": 1.67, "$/W (2023)": 2.3881},
    "ARIES-I": {"Type": "ICRF/LH", "Power (MW)": 96.707, "$/W (2009)": 1.87, "$/W (2023)": 2.6741},
    "ARIES-I'": {"Type": "ICRF/LH", "Power (MW)": 202.5, "$/W (2009)": 1.96, "$/W (2023)": 2.8028},
    "ARIES-RS": {"Type": "ICRF/LH/HFFW", "Power (MW)": 80.773, "$/W (2009)": 3.09, "$/W (2023)": 4.4187},
    "ARIES-IV": {"Type": "ICRF/LH", "Power (MW)": 68, "$/W (2009)": 4.35, "$/W (2023)": 6.2205},
    "ARIES-II": {"Type": "ICRF/LH", "Power (MW)": 66.1, "$/W (2009)": 4.47, "$/W (2023)": 6.3921},
    "ARIES-III'": {"Type": "NBI", "Power (MW)": 163.2, "$/W (2009)": 4.93, "$/W (2023)": 7.0499},
    "ARIES-III": {"Type": "NBI", "Power (MW)": 172, "$/W (2009)": 4.95, "$/W (2023)": 7.0785},
    "ITER": {"Type": "ICRF", "Power (MW)": 5.5, "$/W (2009)": None, "$/W (2023)": 7.865},
    "Average": {"Type": None, "Power (MW)": 110.840125, "$/W (2009)": 3.643333333, "$/W (2023)": 5.209966667},
    "Average (ICRF)": {"Type": None, "Power (MW)": 91.92016667, "$/W (2009)": 2.901666667, "$/W (2023)": 4.149383333},
    "Average (NBI)": {"Type": None, "Power (MW)": 167.6, "$/W (2009)": 4.94, "$/W (2023)": 7.0642},
}

NBIpower = 25 #MW
C22010401= heating_refs["Average (NBI)"]["$/W (2023)"]*NBIpower

ICRFpower = 25 #MW
C22010402= heating_refs["Average (ICRF)"]["$/W (2023)"]*ICRFpower

C220104 = C22010401+C22010402
copy_file('CAS220104_MFE_DT.tex')
overwrite_variable('CAS220104_MFE_DT.tex', 'C22010401', round(C22010401))
overwrite_variable('CAS220104_MFE_DT.tex', 'C22010402', round(C22010402))
overwrite_variable('CAS220104_MFE_DT.tex', 'C220104', round(C220104))
overwrite_variable('CAS220104_MFE_DT.tex', 'NBIPOWER', round(NBIpower,3))
overwrite_variable('CAS220104_MFE_DT.tex', 'ICRFPOWER', round(ICRFpower,3))

#22.1.5 primary structure
#INPUT - choose from pga of 0.1, 0.2, 0.3 or 0.5. PGA stands for peak ground acceleration and increasing values would correlate to an increased risk region.
syst_pga=0.1

#Dictionary of fission reactor costs from "Towards standardized nuclear reactors: Seismic isolation and the cost impact of the earthquake load case"
primary_struct_costs = {
    "analyzecosts":30,
    "unit1seiscosts":25,
    "regrevcosts":30,
    "unit1fabcosts":100,
    "unit10fabcosts":70,
    "pga01engcosts":115,
    "pga01fabcosts":115,
    "pga02engcosts":125,
    "pga02fabcosts":130,
    "pga03engcosts":140,
    "pga03fabcosts":165,
    "pga05engcosts":160,
    "pga05fabcosts":235,
}

#learning credit multiplication factor
learning_credit=0.5
#scaling to system power and learnign credit
scaled_primary_struct_costs = {key: value * PET/1000*learning_credit for key, value in primary_struct_costs.items()}

#standard engineering costs
C22010501= scaled_primary_struct_costs["analyzecosts"]+scaled_primary_struct_costs["unit1seiscosts"] + scaled_primary_struct_costs["regrevcosts"]
#standard fabrication costs
C22010502= scaled_primary_struct_costs["unit1fabcosts"]+scaled_primary_struct_costs["unit10fabcosts"]

copy_file('CAS220105.tex')
#Calculate and overwrite costs based on the input pga for the system
if syst_pga==0.1:
  #pga 0.1 engineering costs
  C22010501 += scaled_primary_struct_costs["pga01engcosts"]
  overwrite_variable('CAS220105.tex', 'pgaengcosts', round(scaled_primary_struct_costs["pga01engcosts"]))
  #pga 0.1 fabrication costs
  C22010502 += scaled_primary_struct_costs["pga01fabcosts"]
  overwrite_variable('CAS220105.tex', 'pgafabcosts', round(scaled_primary_struct_costs["pga01fabcosts"]))
elif syst_pga==0.2:
  #pga 0.2 engineering costs
  C22010501 += scaled_primary_struct_costs["pga02engcosts"]
  overwrite_variable('CAS220105.tex', 'pgaengcosts', round(scaled_primary_struct_costs["pga02engcosts"]))
  #pga 0.2 fabrication costs
  C22010502 += scaled_primary_struct_costs["pga02fabcosts"]
  overwrite_variable('CAS220105.tex', 'pgafabcosts', round(scaled_primary_struct_costs["pga02fabcosts"]))

elif syst_pga==0.3:
  #pga 0.3 engineering costs
  C22010501 += scaled_primary_struct_costs["pga03engcosts"]
  overwrite_variable('CAS220105.tex', 'pgaengcosts', round(scaled_primary_struct_costs["pga03engcosts"]))
  #pga 0.3 fabrication costs
  C22010502 += scaled_primary_struct_costs["pga03fabcosts"]
  overwrite_variable('CAS220105.tex', 'pgafabcosts', round(scaled_primary_struct_costs["pga03fabcosts"]))
elif syst_pga==0.5:
  #pga 0.5 engineering costs
  C22010501 += scaled_primary_struct_costs["pga05engcosts"]
  overwrite_variable('CAS220105.tex', 'pgaengcosts', round(scaled_primary_struct_costs["pga05engcosts"]))
  #pga 0.5 fabrication costs
  C22010502 += scaled_primary_struct_costs["pga05fabcosts"]
  overwrite_variable('CAS220105.tex', 'pgafabcosts', round(scaled_primary_struct_costs["pga05fabcosts"]))

#total cost calculation
C220105 = C22010501+C22010502


#overwriting dictionary items
for var_name, var_value in scaled_primary_struct_costs.items():
    overwrite_variable('CAS220105.tex', var_name, round(var_value,2))

overwrite_variable('CAS220105.tex', 'C220105', round(C220105))
overwrite_variable('CAS220105.tex', 'C22010501', round(C22010501))
overwrite_variable('CAS220105.tex', 'C22010502', round(C22010502))
overwrite_variable('CAS220105.tex', 'PNRL', round(PNRL))

##22.1.6 Vacuum system
#22.1.6.1 Vacuum Vessel
import cadquery as cq

# Parameters
middle_length = vacuum_ir  # Middle part length in meters
middle_diameter = 2*vessel_ir  # Middle part diameter in meters
end_length = 8  # End parts length in meters (each)
end_diameter = 3*vessel_ir  # End parts diameter in meters
fillet_radius = 0.022 * middle_length  # Fillet radius in meters, adjust as necessary
thickness = 0.02  # Thickness in meters

# Create the middle cylinder
middle_cylinder = cq.Workplane("XY").cylinder(middle_length, middle_diameter / 2)

# Create the end cylinders and translate them into position
end_cylinder1 = cq.Workplane("XY").cylinder(end_length, end_diameter / 2).translate((0, 0, middle_length / 2 + end_length / 2))
end_cylinder2 = cq.Workplane("XY").cylinder(end_length, end_diameter / 2).translate((0, 0, -(middle_length / 2 + end_length / 2)))

# Combine the middle cylinder with the end cylinders for outer shape
combined_outer_shape = middle_cylinder.union(end_cylinder1).union(end_cylinder2)

# Create an inner middle cylinder with a smaller diameter to represent the thickness
inner_middle_cylinder = cq.Workplane("XY").cylinder(middle_length, middle_diameter / 2 - thickness)

# Create inner end cylinders with the reduced diameter and translate them into position
inner_end_cylinder1 = cq.Workplane("XY").cylinder(end_length, end_diameter / 2 - thickness).translate((0, 0, middle_length / 2 + end_length / 2))
inner_end_cylinder2 = cq.Workplane("XY").cylinder(end_length, end_diameter / 2 - thickness).translate((0, 0, -(middle_length / 2 + end_length / 2)))

# Combine the inner middle cylinder with the inner end cylinders for inner shape
combined_inner_shape = inner_middle_cylinder.union(inner_end_cylinder1).union(inner_end_cylinder2)
vesvol=combined_inner_shape.val().Volume()


# Subtract the combined inner shape from the outer shape for material volume calculation
material_shape = combined_outer_shape.cut(combined_inner_shape)

# Calculate the material volume
materialvolume = material_shape.val().Volume()

# Now apply the fillets to the outer shape (for display purposes)
final_shape_with_fillets = combined_outer_shape.edges().fillet(fillet_radius)

# Material properties (density and cost)
ss_density = 6700  # kg/m^3
ss_cost = 5  # $/kg

# Calculate mass and cost
vesmfr = 10
massstruct = materialvolume * ss_density
vesmatcost = ss_cost * massstruct
C22010601 = vesmatcost*vesmfr/1e6

# Display the final shape
#display(final_shape_with_fillets)

#COOLING 22.1.6.2
def k_steel(T):
    return 10

T_mag = 20
T_env = 300


#Power in from thermal conduction through support
def Qin_struct(no_beams, beam_cs_area, beam_length,k):
    return k*beam_cs_area*no_beams/beam_length *(T_env-T_mag)/1e6


#power in from neutron flux, assume 95% is abosrbed in the blanket
def Qin_n():
    return PNEUTRON*0.05/1e6

#cooling from power in/half carnot COP
C_frac=0.1
def Q_cooling(Qin,C_frac):
    COP = T_mag/(T_env-T_mag)*C_frac #Assume 10% of carnot efficiency
    return Qin/COP, COP


#For 1 coil, assume 20 support beams, 5m length, 0.5m^2 cs area, target temp of 20K, env temp of 300 K
Qin = Qin_struct(20, 1, 5,k_steel((T_env+T_mag)/2))+Qin_n()

def Qin_tot(Qin,no_coils):
    return Qin * no_coils


#Cooling power requirements for various temperature differences
# Generate a range of target temperatures from 20 K to 300 K
T_mag_range = np.linspace(4, 200, 100)  # Target temperatures

# Calculating cooling power requirement for different target temperatures
cooling_power_requirements = Qin_tot(Qin,13) / (T_mag_range / (T_env - T_mag_range)*C_frac
)
fig, ax = plt.subplots(figsize=(10, 6))

# Plotting on the axes
ax.plot(T_mag_range, cooling_power_requirements)
ax.set_xlabel('Target Temperature (K)')
ax.set_ylabel('Cooling Power Requirement (MW)')
# ax.set_title('Cooling Power Requirement vs. Target Temperature')
ax.grid(True)

# Display the plot
plt.show()

# Export as PDF
fig.savefig(os.path.join(figures_directory, 'cooling_efficiency.pdf'), bbox_inches='tight')

#Scaling cooling costs from STARFIRE see pg40 https://cer.ucsd.edu/_files/publications/UCSD-CER-13-01.pdf
#Starfire COP
COP_starfire = 4.2 / (300 - 4.2)*0.15
#STARFIRE cooling at 4.2 K
QSCItarfire = 20e3 #20 kW
#Calculating starfire cooling at system operating temp in MW
Q_cooling_temp = QSCItarfire * (Q_cooling(Qin,C_frac)[1]/ COP_starfire)/1e6

cost_starfire = 17.65*1.43 #17.65 M USD in 2009 for 20kW at 4.2 K, adjusted to inflation
C22010602 = Qin/Q_cooling_temp *17.65*1.43 #M USD, scaled to system size, at system temperature, from the 20 kW cooling, 17.65 STARFIRE system

#VACUUM PUMPING 22.1.6.3
#assume 1 second vac rate
#cost of 1 vacuum pump, scaled from 1985 dollars
cost_pump = 40000
#48 pumps needed for 200^3 system
vpump_cap = 200/48 #m^3 capable of beign pumped by 1 pump
no_vpumps = int(vesvol/vpump_cap)#Number of vacuum pumps required to pump the full vacuum in 1 second
C22010603  = no_vpumps*cost_pump/1e6

#ROUGHING PUMP 22.1.6.4
#from STARFIRE, only 1 needed
C22010604 = 120000*2.85/1e6



C220106 = C22010601  +C22010602 +C22010603+C22010604
copy_file('CAS220106_MFE.tex')
overwrite_variable('CAS220106_MFE.tex', 'C22010601', round(C22010601))
overwrite_variable('CAS220106_MFE.tex', 'C22010602', round(C22010601))
overwrite_variable('CAS220106_MFE.tex', 'C22010603', round(C22010603))
overwrite_variable('CAS220106_MFE.tex', 'C22010604', round(C22010604,2))
overwrite_variable('CAS220106_MFE.tex', 'C220106', round(C220106))
overwrite_variable('CAS220106_MFE.tex', 'vesvol', round(vesvol))
overwrite_variable('CAS220106_MFE.tex', 'materialvolume', round(materialvolume))
overwrite_variable('CAS220106_MFE.tex', 'massstruct', round(massstruct))
overwrite_variable('CAS220106_MFE.tex', 'vesmatcost', round(vesmatcost/1e6,1))
overwrite_variable('CAS220106_MFE.tex', 'vesmfr', round(vesmfr))
overwrite_variable('CAS220106_MFE.tex', 'Qin', round(Qin,2))

#Cost Category 22.1.7 Power supplies

#Scaled relative to ITER for a 500MW fusion power syste
lcredit = 0.5# learning credit.
C220107 = 269.6 * PNRL/500*lcredit #cost in kIUA
C220107 = C220107*2 #assuming 1kIUA equals $2 M

copy_file('CAS220107_MFE.tex')
overwrite_variable('CAS220107_MFE.tex', 'C220107', round(C220107))
overwrite_variable('CAS220107_MFE.tex', 'PNRL', round(PNRL))

#22.1.8 Divertor
#Simple volumetric calculation based on reactor geometry, user input, and tungsten material properties (see "materials" dictionary)
divertorMajRad = rCentreList[0]
divertorMinRad = firstwall_ir-axis_ir
divertorThicknessZ=0.2 #[m]
divertorThicknessR= divertorMinRad*2#[m]
divertorMaterial = materials["W"] #Tungsten
divertorVol = ((divertorMajRad+divertorThicknessR)**2-(divertorMajRad-divertorThicknessR)**2)*np.pi*divertorThicknessZ #volume of the divertor based on TF coil radius
divertorMass= divertorVol*divertorMaterial["rho"]
divertorMatCost=divertorMass*divertorMaterial["c_raw"]
divertorCost=divertorMatCost*divertorMaterial["m"]
C220108 = divertorCost/1e6

copy_file('CAS220108_MFE.tex')
overwrite_variable('CAS220108_MFE.tex', 'C220108', round(C220108))
overwrite_variable('CAS220108_MFE.tex', 'divertorMajRad', round(divertorMajRad))
overwrite_variable('CAS220108_MFE.tex', 'divertorMinRad', round(divertorMinRad))
overwrite_variable('CAS220108_MFE.tex', 'divertorThicknessZ', round(divertorThicknessZ))
overwrite_variable('CAS220108_MFE.tex', 'divertorMaterial', divertorMaterial)
overwrite_variable('CAS220108_MFE.tex', 'divertorVol', round(divertorVol))
overwrite_variable('CAS220108_MFE.tex', 'divertorMass', round(divertorMass))

#22.1.9 Direct Energy Converter
import math
#Subsystem costs
de_costs = {
    "expandertank": 16,
    "expandercoilandneutrontrapcoil": 33,
    "convertoegatevalve": 0.1,
    "neutrontrapshielding": 1,
    "vacuumsystem": 16,
    "gridsystem": 27,
    "heatcollectionsystem": 6,
    "electricaleqpmt": 13,
    "costperunit": 112,
    "totaldeunitcost": 447,
    "engineering15percent": 67,
    "contingency15percent": 77,
    "totaldecost": 591
}

def de_scaling(syst_power, flux_lim, input_dict):
    scaled_dict = {}
    for key, value in input_dict.items():
        scaled_value = value * syst_power * (1 / math.sqrt(flux_lim)) ** 3
        scaled_dict[key] = scaled_value
    return scaled_dict

scaled_de_costs=de_scaling(1, 2, de_costs)
C220109 = scaled_de_costs['totaldecost']
C220109=0
"""
WRITE TO LATEX
"""
copy_file('CAS220109_MFE.tex')
# Iterate over the scaled_de_costs dictionary
for key, value in scaled_de_costs.items():
    # replace each value in the .tex file
    overwrite_variable('CAS220109_MFE.tex', key, round(value, 1))
overwrite_variable('CAS220109_MFE.tex', 'C220109', round(C220109))

#Cost Category 22.1.11 Installation costs

# Define labor rate
lr = 1600 / 1e6  # 1600 dollars per day for skilled labor

# Assuming 'r' (major radius of the system) and 'NMOD' (number of modules) are predefined
# Replace these with actual values or calculations as needed
r = 8  # replace with actual value for r
NMOD = 1  # replace with actual value for NMOD


# Calculations
constructionworker = 20 * r / 4
C_22_1_11_in = NMOD * constructionTime * (lr * 20 * 300)
C_22_1_11_1_in = NMOD * ((lr * 200 * constructionworker) + 0)  # 22.1 first wall blanket
C_22_1_11_2_in = NMOD * ((lr * 150 * constructionworker) + 0)  # 22.2 shield
C_22_1_11_3_in = NMOD * ((lr * 100 * constructionworker) + 0)  # coils
C_22_1_11_4_in = NMOD * ((lr * 30 * constructionworker) + 0)  # supplementary heating
C_22_1_11_5_in = NMOD * ((lr * 60 * constructionworker) + 0)  # primary structure
C_22_1_11_6_in = NMOD * ((lr * 200 * constructionworker) + 0)  # vacuum system
C_22_1_11_7_in = NMOD * ((lr * 400 * constructionworker) + 0)  # power supplies
C_22_1_11_8_in = 0  # guns
C_22_1_11_9_in = NMOD * ((lr * 200 * constructionworker) + 0)   # direct energy converter
C_22_1_11_10_in = 0  # ECRH

# Total cost calculations
C220111 = (C_22_1_11_in + C_22_1_11_1_in + C_22_1_11_2_in + C_22_1_11_3_in + C_22_1_11_4_in + C_22_1_11_5_in + C_22_1_11_6_in + C_22_1_11_7_in + C_22_1_11_8_in + C_22_1_11_9_in + C_22_1_11_10_in)

copy_file('CAS220111_MFE.tex')
overwrite_variable('CAS220111_MFE.tex', 'C220111', round(C220111))

#Cost category 22.1.19 Scheduled Replacement Cost
C220119=0

copy_file('CAS220119_MFE.tex')
overwrite_variable('CAS220119_MFE.tex', 'C220119', round(C220119))

#Cost category 22.1 total
C220100 = C220101 + C220102 + C220103 + C220104 + C220105 + C220106 + C220107 +  C220111

#MAIN AND SECONDARY COOLANT Cost Category 22.2
NMOD=1


#C_22_2_1  = 233.9 * (PTH/3500)^0.55; 	#Li(f), PbLi, He:                %Primary coolant(i):
C220201  = 268.5  * (NMOD * PTH/3500) * 1.71 #am assuming a linear scaling	%Li(f), PbLi, He:
#Primary coolant(i):  1.85 is due to inflation%the CPI scaling of 1.71 comes from:
#https://www.bls.gov/data/inflation_calculator.htm scaled relative to 1992 dollars (despite 2003 publication date)
C220201 = 166 * (NMOD * PNET/1000)  #this is the Sheffield cost for a 1GWe system
#C_22_2_1  = 75.0 * (PTH/3500)^0.55   	#OC, H2O(g)
C220202 = 40.6 * (PTH/3500)**0.55     #Intermediate coolant system
C220203  = 0
#75.0 * (PTH/3500)^0.55      Secondary coolant system

C220200=  round(C220201 + C220202 + C220203,1)             #Main heat-transfer system (NSSS):

copy_file('CAS220200_DT.tex')
overwrite_variable('CAS220200_DT.tex', 'C220200', round(C220200))
overwrite_variable('CAS220200_DT.tex', 'C220201', round(C220201))
overwrite_variable('CAS220200_DT.tex', 'C220202', round(C220202))
overwrite_variable('CAS220200_DT.tex', 'C220203', round(C220203))
overwrite_variable('CAS220200_DT.tex', 'primaryC', primaryC)
overwrite_variable('CAS220200_DT.tex', 'secondaryC', secondaryC)

#Cost Category 22.3  Auxiliary cooling


C220300    = round(1.10 * 1e-3 * NMOD * PTH * 2.02,1)          #Auxiliary cooling systems %the CPI scaling of 2.02 comes from: https://www.bls.gov/data/inflation_calculator.htm scaled relative to 1992 dollars (despite 2003 publication date)

copy_file('CAS220300.tex')
overwrite_variable('CAS220300.tex', 'C220300', round(C220300,1))

#Cost Category 22.4 Radwaste

C220400    = round(1.96 * 1e-3 * PTH * 2.02  ,1)     	#Radioactive waste treatment %the CPI scaling of 1.96 comes from: https://www.bls.gov/data/inflation_calculator.htm scaled relative to 1992 dollars (despite 2003 publication date)

copy_file('CAS220400.tex')
overwrite_variable('CAS220400.tex', 'C220400', C220400)

#Cost Category 22.5 Fuel Handling and Storage


inflation = 1.43
C2205010ITER = 20.465*inflation
C2205020ITER = 7*inflation
C2205030ITER = 22.511*inflation
C2205040ITER = 9.76*inflation
C2205050ITER = 22.826*inflation
C2205060ITER = 47.542*inflation
C22050ITER = C2205010ITER+C2205020ITER+C2205030ITER+C2205040ITER+C2205050ITER+C2205060ITER #ITER inflation cost


lcredit = 0.8 #%learning curve
ltoak = 10 ** (math.log10(lcredit) / math.log10(2))


C220501 = C2205010ITER*ltoak
C220502 = C2205020ITER*ltoak
C220503 = C2205030ITER*ltoak
C220504 = C2205040ITER*ltoak
C220505 = C2205050ITER*ltoak
C220506 = C2205060ITER*ltoak
C220500 = C220501+C220502+C220503+C220504+C220505+C220506 #ITER inflation cost

variable_dictionary = {
    "lcredit": lcredit, "ltoak": ltoak, "C2205010ITER": C2205010ITER, "C2205020ITER": C2205020ITER,
    "C2205030ITER": C2205030ITER, "C2205040ITER": C2205040ITER, "C2205050ITER": C2205050ITER,
    "C2205060ITER": C2205060ITER, "C22050ITER": C22050ITER, "C220501": C220501, "C220502": C220502,
    "C220503": C220503, "C220504": C220504, "C220505": C220505, "C220506": C220506, "C220500": C220500
}

# Copying the .tex file
copy_file('CAS220500_DT.tex')
# Overwriting the placeholders in the .tex file
for var_name, var_value in variable_dictionary.items():
    overwrite_variable('CAS220500_DT.tex', var_name, round(var_value,1))

#Cost Category 22.6 Other Reactor Plant Equipment


C220600 = round(11.5*(PNET/1000)**(0.8),1) #from waganer

copy_file('CAS220600.tex')
overwrite_variable('CAS220600.tex', 'C220600', round(C220600))

#Cost Category 22.7 Instrumentation and Control

# 22.07.00.00    instrumentation & control(i&c)
C220700 = 85

copy_file('CAS220700.tex')
overwrite_variable('CAS220700.tex', 'C220700', round(C220700))

#Reactor Plant Equipment (RPE) total
C220000 = C220100 + C220200 + C220300 + C220400 + C220500 + C220600 + C220700
copy_file('CAS220000.tex')
overwrite_variable('CAS220000.tex', 'C220000', C220000)

variables_to_overwrite = {'BFSrho': materials['BFS']['rho'], 'BFScraw': materials['BFS']['c_raw'], 'BFSm': materials['BFS']['m'],
    'FSrho': materials['FS']['rho'], 'FScraw': materials['FS']['c_raw'], 'FSm': materials['FS']['m'],
    'FSsigma': materials['FS']['sigma'],
    'Li4SiO4rho': materials['Li4SiO4']['rho'], 'Li4SiO4craw': materials['Li4SiO4']['c_raw'],
    'Li4SiO4m': materials['Li4SiO4']['m'], 'Fliberho': materials['Flibe']['rho'], 'Flibec': materials['Flibe']['c'],
    'Wrho': materials['W']['rho'], 'Wcraw': materials['W']['c_raw'], 'Wm': materials['W']['m'],
    'SiCrho': materials['SiC']['rho'], 'SiCcraw': materials['SiC']['c_raw'], 'SiCm': materials['SiC']['m'],
    'Inconelrho': materials['Inconel']['rho'], 'Inconelcraw': materials['Inconel']['c_raw'], 'Inconelm': materials['Inconel']['m'],
    'Curho': materials['Cu']['rho'], 'Cucraw': materials['Cu']['c_raw'], 'Cum': materials['Cu']['m'],
    'Polyimiderho': materials['Polyimide']['rho'], 'Polyimidecraw': materials['Polyimide']['c_raw'], 'Polyimidem': materials['Polyimide']['m'],
    'YBCOrho': materials['YBCO']['rho'], 'YBCOc': materials['YBCO']['c'], 'Concreterho': materials['Concrete']['rho'],
    'Concretecraw': materials['Concrete']['c_raw'], 'Concretem': materials['Concrete']['m'],
    'SS316rho': materials['SS316']['rho'], 'SS316craw': materials['SS316']['c_raw'], 'SS316m': materials['SS316']['m'],
    'SS316sigma': materials['SS316']['sigma'], 'Nb3Snc': materials['Nb3Sn']['c'], 'Incoloyrho': materials['Incoloy']['rho'],
    'Incoloycraw': materials['Incoloy']['c_raw'], 'Incoloym': materials['Incoloy']['m'],'Pbrho': materials['Pb']['rho'], 'Pbcraw': materials['Pb']['c_raw'],
    'Pbm': materials['Pb']['m'],"PbLirho":materials["PbLi"]["rho"],"PbLic":materials["PbLi"]["c"],'Lirho': materials['Li']['rho'], 'Licraw': materials['Li']['c_raw'], 'Lim': materials['Li']['m']
}


for var_name, var_value in variables_to_overwrite.items():
    overwrite_variable('CAS220000.tex', var_name, round(var_value,2))

#Cost Category 23 Turbine Plant Equipment


C230000=round(NMOD * PET * 0.219 *1.15,1)

copy_file('CAS230000.tex')
overwrite_variable('CAS230000.tex', 'C230000', round(C230000))

#Cost Category 24 Electric Plant Equipment

C240000= round(NMOD * PET * 0.054 * 1.15,1)

copy_file('CAS240000.tex')
overwrite_variable('CAS240000.tex', 'C240000', round(C240000))

#Cost Category 25 Miscellaneous Plant Equipment

C250000  = round( NMOD* PET  * 0.038 * 1.15,1)   #factor of 1.15 obtained from escalating relative to 2019 $

copy_file('CAS250000.tex')
overwrite_variable('CAS250000.tex', 'C250000', round(C250000))

#Cost Category 26 Heat Rejection

C260000 = round(NMOD * PNET * 0.107 * 1.15,1) #heat rejection scaled as NET electric power escalated relative to 2019 dollars to 2026 dollars

copy_file('CAS260000.tex')
overwrite_variable('CAS260000.tex', 'C260000', round(C260000))

#Cost Category 27 Special Materials

# Assuming the values for c_Flibe, c_Pb, c_Li, and MLM are defined elsewhere in your code
# Replace 'value_x' with actual values
#c_Flibe = value_x  # replace value_x with actual value for c_Flibe
#c_Pb = value_y     # replace value_y with actual value for c_Pb
#c_Li = value_z     # replace value_z with actual value for c_Li
#MLM = value_a      # replace value_a with actual value for MLM

# Define the primary coolants list
primary_coolant = ["Lead Lithium (PbLi)", "Lithium (Li)", "FLiBe", "other eutectic salt", "helium", "dual coolant: PbLi and He", "water"]

# Select the first coolant
primaryC = primary_coolant[1]

# Select the coolant and calculate C_27_1
if primaryC == 'FLiBe':
    C_27_1 = 1000 * 2130 * c_Flibe / 1e6
elif primaryC == 'Lead Lithium (PbLi)':
    f_6Li = 0.1
    FPCPPFb = 0.9
    C_27_1 = (c_Pb * FPCPPFb * MLM * 1000 + c_Li * f_6Li * MLM * 1000) / 1e6
elif primaryC == 'Lithium (Li)':
    C_27_1 = 1000 * 2130 * 50 / 1e6
elif primaryC == 'other eutectic salt':
    C_27_1 = 1000 * 2130 * 50 / 1e6
elif primaryC == 'helium':
    C_27_1 = 1000 * 2.13 * 50 / 1e6
elif primaryC == 'dual coolant: PbLi and He':
    C_27_1 = 1000 * 2.13 * 50 / 1e6
elif primaryC == 'water':
    C_27_1 = 1000 * 1000 * 1 / 1e6

# Additional calculations
C_27_4 = 0.41 * 1.71  # Other
C_27_5 = 0.21 * 1.71  # Reactor-building cover gas
C270000 = round(C_27_1 + C_27_4 + C_27_5,1)

copy_file('CAS270000.tex')
overwrite_variable('CAS270000.tex', 'C270000', round(C270000))

#cost category 28 Digital Twin

C280000=5

copy_file('CAS280000.tex')
overwrite_variable('CAS280000.tex', 'C280000', round(C280000))

#Cost Category 29 Contingency
C290000= 0.1 * (C210000+C210000 + C220000 + C230000 + C240000 + C250000 + C260000 + C270000 + C280000 + C280000)

copy_file('CAS290000.tex')
overwrite_variable('CAS290000.tex', 'C290000', round(C290000))

C200000 = C210000+C210000 + C220000 + C230000 + C240000 + C250000 + C260000 + C270000 + C280000 + C280000 + C290000
copy_file('CAS200000.tex')
overwrite_variable('CAS200000.tex', 'C200000', round(C200000))

"""# Indirect Costs"""

#Cost Category 30 Capitalized Indirect Service Costs (CISC)

# Define LSA
LSA = 2

# Indirect Cost Factors for different LSA levels
fac_91 = [0.1130, 0.1200, 0.1280, 0.1510]  # x TDC [90]
fac_92 = [0.0520, 0.0520, 0.0520, 0.0520]  # x TDC [90]
fac_93 = [0.0520, 0.0600, 0.0640, 0.0870]  # x TDC [90]
fac_94 = [0.1826, 0.1848, 0.1866, 0.1935]  # applies only to C90, x TDC [90+91+92+93]
fac_95 = [0.0000, 0.0000, 0.0000, 0.0000]  # x TDC [90+91+92+93+94]
fac_96 = [0.2050, 0.2391, 0.2565, 0.2808]  # applied only to C90, x TDC [90+91+92+93+94]
fac_97 = [0.2651, 0.2736, 0.2787, 0.2915]  # applied only to C90, x TDC [90+91+92+93+94+95+96]
fac_98 = [0.0000, 0.0000, 0.0000, 0.0000]  # x TDC [90+91+92+93+94+95+96]


#Cost Category 31 – Field Indirect Costs - previously Cost Category 93

C310000LSA = fac_93[LSA - 1] * C200000
#0.060 * C_90; %NMOD*(/1e6)/A_power * A_C_93 #Field Office Engineering and Services  Table 3.2-VII of Ref. [1]

C310000 = (PNET/150)**-0.5 * PNET * 0.02 * constructionTime

#Cost Category 32  – Construction Supervision - previously Cost Category 91

C320000LSA = fac_91[LSA - 1] * C200000
C320000 = (PNET/150)**-0.5 * PNET * 0.05 * constructionTime #this takes the 316$/kW and divides by 6 to obtain a cost per year of 0.053$/MW and applies to PE, which is the net electric.  There are arguments that this should be applied to the gross electric, if we consider demonstration plants, but this code is not set up for FOAK currently.

#Cost Category 33 – Commissioning and Start-up Costs

#Cost Category 34 – Demonstration Test Run

#Cost Category 35 – Design Services Offsite

C350000 = (PNET/150)**-0.5 * PNET * 0.03 * constructionTime

C350000LSA = fac_92[LSA - 1] * C200000
#0.052 * C_90; %NMOD*(/1e6)/A_power * A_C_92; %Home Office Engineering and Services  Table 3.2-VII of Ref. [1]

C300000=C310000+C320000+C350000

copy_file('CAS300000.tex')
overwrite_variable('CAS300000.tex', 'constructionTime', constructionTime)
overwrite_variable('CAS300000.tex', 'C300000', round(C300000))
overwrite_variable('CAS300000.tex', 'C320000', round(C320000))
overwrite_variable('CAS300000.tex', 'C310000LSA', round(C310000LSA))
overwrite_variable('CAS300000.tex', 'C310000', round(C310000))
overwrite_variable('CAS300000.tex', 'C350000LSA', round(C350000LSA))
overwrite_variable('CAS300000.tex', 'C350000', round(C350000))

#Cost Category 40 Capitalized Owner’s Cost (COC)

C400000LSA = fac_91[LSA - 1] * C200000

C400000 =C400000LSA
#Cost Category 41 – Staff Recruitment and Training

C410000=0

#Cost Category 42 – Staff Housing

C420000=0

#Cost Category 43 – Staff Salary-Related Costs

C430000 = 0

#Cost Category 44 – Other Owner’s Costs

C440000 = 0

#C400000 = C410000 + C420000 + C430000 + C440000

copy_file('CAS400000.tex')
overwrite_variable('CAS400000.tex', 'C400000LSA', round(C400000LSA))
overwrite_variable('CAS400000.tex', 'C400000', round(C400000))

#Cost Category 50 Capitalized Supplementary Costs (CSC)


#Cost Category 51 – Shipping and Transportation Costs

C510000 = 8

#Cost Category 52 – Spare Parts

C520000 = 0.1 * (C230000 + C240000 + C250000 + C260000 + C270000 + C280000)

#Cost Category 53 – Taxes

C530000 = 100

#Cost Category 54 – Insurance

C540000 = 1

#Cost Category 55 – Initial Fuel Load

#$22 M to $34 M (2016 USD) for a standard 150 MWe FPP.

C550000 = PNET/150 * 34

#Cost Category 58 – Decommissioning Costs

C580000 = 200

#Cost Category 59 – Contingency on Supplementary Costs

C590000 = 0.1 * (C580000 + C550000 + C540000 + C530000 + C520000 + C510000)
C590000=0

C500000 = C510000 + C520000 + C530000 + C540000 + C550000 + C580000 + C590000
''
copy_file('CAS500000.tex')
overwrite_variable('CAS500000.tex', 'C500000', round(C500000))
overwrite_variable('CAS500000.tex', 'C510000', round(C510000))
overwrite_variable('CAS500000.tex', 'C520000', round(C520000))
overwrite_variable('CAS500000.tex', 'C530000', round(C530000))
overwrite_variable('CAS500000.tex', 'C540000', round(C540000))
overwrite_variable('CAS500000.tex', 'C550000', round(C550000))
overwrite_variable('CAS500000.tex', 'C580000', round(C580000))
overwrite_variable('CAS500000.tex', 'C590000', round(C590000))

#Cost Category 60 Capitalized Financial Costs (CFC)

A_C_98 = 115
A_power = 1000

#Cost Category 61 – Escalation - formerly Cost Category 98: Escalation During Construction
C610000 = NMOD*(PNRL)/A_power * A_C_98 #Escalation during Construction (EDC) Table 3.2-X of Ref. [1]



# Cost Category 63 – Interest During Construction (IDC) formerly cost category 97
#for inflation rate = 0.05/y (cf. ARIES) and 0.02/y (lower and more modern).  The 0.05/y values check with Table 2.2-XVII p. 2-59 of the ARIES-II/IV report.
#Construction lead time is varied between 3 and 12 years. STARFIRE (with a published schedule) and ARIES used 6 years, which could be considered optimistic for a (big) tokamak.  We might be able to defend a lower base time for the smaller ARPA-E cases invoking factory fabrication and modularity (already assumed by STARFIRE).
#Your calculations so far have used the 6-yr f_IDC for 0.05/y inflation rate for Acct. 97; a sensitivity of TCC as a function of construction lead time is what we had in mind.
#f_EDC for constant-dollar costing is zero.  Nominal- (then-current dollar) costing includes f_EDC in Acct. 98.
#I am a bit surprised that the f_IDC for 0.02/y is slightly larger than the corresponding 0.05/y value.
#f_IDC - Interest During Construction for constant dollars
#f_EDC - Escalation During Construction
#a sensitivity of TCC as a function of construction lead time is what we had in mind

#yinf=  0.0500/y
#          			f_IDC(97)   	f_EDC(98)
#  con lead 	constant 	nominal 	nominal
#   3 		0.0863  	0.1624  	0.0951
#   4  		0.1118  	0.2119  	0.1394
#   5  		0.1381  	0.2637  	0.1887
#   6  		0.1652  	0.3178  	0.2436    <<<<
#   7  		0.1931  	0.3743  	0.3045
#   8  		0.2219  	0.4332  	0.3719
#   9  		0.2515  	0.4948  	0.4466
#  10  		0.2821  	0.5591  	0.5291
#  11  		0.3136  	0.6263  	0.6201
#  12  		0.3460  	0.6964  	0.7206

yearsconstr = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
costfac90 = [0.0863, 0.1118, 0.1381, 0.1652, 0.1931, 0.2219, 0.2515, 0.2821, 0.3136, 0.3460];

# yinf=  0.0200/y
#          f_IDC(97)   f_EDC(98)
#     constant nominal nominal
#   3  0.0863  0.1637  0.0376
#   4  0.1118  0.2144  0.0546
#   5  0.1381  0.2678  0.0733
#   6  0.1652  0.3239  0.0938
#   7  0.1931  0.3829  0.1162
#   8  0.2219  0.4450  0.1407
#   9  0.2515  0.5104  0.1675
#  10  0.2821  0.5792  0.1968
#  11  0.3136  0.6516  0.2288
#  12  0.3460  0.7279  0.2637

C630000LSA = fac_97[LSA - 1] * C200000

#C_97_sens = costfac90 * (C_90 + C_96 + C_94 + C_93 + C_92 + C_91);
#(/1e6)/A_power * A_C_97; %Interest during Construction (IDC)  Table 3.2-X of Ref. [1]

C630000 = PNET * 0.099 * constructionTime


C600000 = C630000 + C610000
copy_file('CAS600000.tex')
overwrite_variable('CAS600000.tex', 'C600000', round(C600000))
overwrite_variable('CAS600000.tex', 'C610000', round(C610000))
overwrite_variable('CAS600000.tex', 'C630000LSA', round(C630000LSA))
overwrite_variable('CAS600000.tex', 'C630000', round(C630000))

#Total Capital costs 99

C990000 = C100000 + C200000+ C300000 + C400000 + C500000 + C600000

#Cost Category  70 Annualized O\&M Cost (AOC)

C_OM = 60 * PNET * 1000

#C750000 = 0.1 * (C220000) scheduled replacement costs

C700000 = C_OM/1e6 #+ C750000

copy_file('CAS700000.tex')
overwrite_variable('CAS700000.tex', 'C700000', round(C700000))
#overwrite_variable('CAS700000.tex', 'C750000', round(C750000))

#Cost Category 80: Annualized Fuel Cost (AFC)

y=0.0245 #inflation at 2.45%
p_a = 0.9 #plant availability factor in Miller 2003 was 0.76
C_F = 0.03 * (8760 * PNET*NMOD * p_a) / (1 + y )**constructionTime #hours * power = MWh
C_F=50


m_D = 3.342*10**(-27) # (kg)
u_D = 2175 #Where u_D ($/kg) = 2175 ($/kg) from STARFIRE * 1.12345/0.42273 [GDP IPD ratio for 2019/1980]
C_F = NMOD * PNRL * 1e6 * 3600 * 8760 * u_D * m_D * p_a / (17.58 * 1.6021e-13)

C800000 = C_F/1e6
copy_file('CAS800000_DT.tex')
overwrite_variable('CAS800000_DT.tex', 'C800000', round(C800000))

#Cost Category 90: Annualized Financial Costs (AFC)

f_cr = 0.09   #Capital return factor
C900000= f_cr * C990000

copy_file('CAS900000.tex')
overwrite_variable('CAS900000.tex', 'C900000', round(C900000))

#LCOE

C1000000 = (C900000*1e6 + (C700000*1e6 + C800000*1e6) * (1 + y) ** constructionTime) / (8760 * PNET * NMOD * p_a)
C2000000 = C1000000 / 10

copy_file('LCOE.tex')
#overwrite_variable('LCOE.tex', 'C750000', round(C750000))
overwrite_variable('LCOE.tex', 'C1000000', round(C1000000))
overwrite_variable('LCOE.tex', 'C2000000', round(C2000000))
overwrite_variable('LCOE.tex', 'C900000', round(C900000))
overwrite_variable('LCOE.tex', 'C800000',round( C800000))
overwrite_variable('LCOE.tex', 'C700000', round(C700000))

#Cost Table

cost_vals =[C100000,C200000,C210000, C220000, C220100, C220101, C220102, C220103, C220104, C220105, C220106,
    C220107, C220108, C220109, C220111, C220119, C220200, C220300, C220400, C220500, C220600, C220700,
    C230000, C240000, C250000, C260000, C270000,C280000,C290000,C300000,C400000,C500000,C600000,C990000

]
cost_vals = [round(val, 1) for val in cost_vals]

placeholders = [ "C100000","C200000","C210000", "C220000", "C220100", "C220101", "C220102", "C220103", "C220104", "C220105", "C220106",
    "C220107", "C220108", "C220109", "C220111","C220119", "C220200", "C220300", "C220400", "C220500", "C220600", "C220700",
    "C230000", "C240000", "C250000", "C260000", "C270000","C280000","C290000","C300000","C400000","C500000","C600000","C990000"]


#Percentages
percent_vals  =[C100000/C990000,C200000/C990000,C210000/C990000, C220000/C990000, C220100/C990000, C220101/C990000,
                 C220102/C990000, C220103/C990000, C220104/C990000, C220105/C990000, C220106/C990000,
                 C220107/C990000, C220108/C990000, C220109/C990000, C220111/C990000,C220119/C990000, C220200/C990000, C220300/C990000,
                 C220400/C990000, C220500/C990000, C220600/C990000, C220700/C990000,
                 C230000/C990000, C240000/C990000, C250000/C990000, C260000/C990000, C270000/C990000,
                 C280000/C990000,C290000/C990000,C300000/C990000,C400000/C990000,C500000/C990000,C600000/C990000,C990000/C990000

]
percent_vals = [round(val*100) for val in percent_vals]

percent_placeholders = [ "C100000pp","C200000pp","C210000pp", "C220000pp", "C220100pp", "C220101pp", "C220102pp", "C220103pp", "C220104pp", "C220105pp", "C220106pp",
    "C220107pp", "C220108pp", "C220109pp", "C220111pp","C220119pp", "C220200pp", "C220300pp", "C220400pp", "C220500pp", "C220600pp", "C220700pp",
    "C230000pp", "C240000pp", "C250000pp", "C260000pp", "C270000pp","C280000pp","C290000pp","C300000pp","C400000pp","C500000pp","C600000pp","C990000pp"
]

M30 =C300000/C990000*2844
M40 =311.8
M50=C500000/C990000*2844
M60=C600000/C990000*2844

#ARIES AT
A_power = 1719 #this is the net electric power
ARIESAT_values = np.array([
     10.6, 1521, 253.5, 761, 482,64.3,69.4,126.7, 41.1,26.9,98.8,50.7,4.1,np.nan,np.nan,126,np.nan,np.nan,np.nan,np.nan,
    3.49, 243, 98.5, 47.4, 23.3, 83.8, np.nan, 311.8,
     M30,277.8,M50,M60,2844+M30+M40+M50+M60
])*1.35#Inflation factor


#ARIES CS
"""
M30 =C300000/C990000*4479.7
M40 =C400000/C990000*4479.7
M50=C500000/C990000*4479.7
M60=C600000/C990000*4479.7
A_power = 2920 #this is the net electric power used because Anklan uses $/kWe
ARIESCS_values = np.array([
     12.9, 2619.7, 336.1, 1538.9, 976.15,59.4,228.6, 334.35, 66.4,73.1,137.1,70.6,6.6,0,0,0,474.8,0,0,
    0, 0, 3.49, 314.6, 138.8, 71, 56.1+64.3,151.3, 0,0,
     M30,M40,M50,M60,4479.7+M30+M40+M50+M60
])*1.35#Inflation factor"""

"""#ARIES ST
M30 =C300000/C990000*4479.7
M40 =C400000/C990000*4479.7
M50=C500000/C990000*4479.7
M60=C600000/C990000*4479.7
A_power = 2920 #this is the net electric power

ARIESST_values = np.array([
     10.6, 4479.7, 370.8, 1244.1, 648.7,50.2,113.1,102.6, 212.5,37.4,48.1,71.6,8.8,np.nan,np.nan,358,np.nan,np.nan,np.nan,np.nan,
    3.49, 339, 125.4,  77.9, 64.3, 108.9, np.nan,555.1,
     M30,429,M50,M60,2844+M30+M40+M50+M60
])*1.35#Inflation factor"""

ARIESAT_value_placeholders = [
    "M100000", "M200000", "M210000", "M220000", "M220100", "M220101", "M220102", "M220103",
    "M220104", "M220105", "M220106", "M220107", "M220108", "M220109", "M220111","M220119",
    "M2202", "M2203", "M2204", "M2205", "M2206", "M2207", "M23", "M24",
    "M25", "M26", "M27", "M28", "M29", "M30", "M40", "M50", "M60", "M99"
]


ARIESAT_percentages_p = [
    "M10pp", "M20pp", "M21pp", "M22pp", "M2201pp", "M22.0101pp", "M22.0102pp", "M22.0103pp",
    "M22.0104pp", "M22.0105pp", "M22.0106pp", "M22.0107pp", "M22.0108pp", "M22.0109pp", "M220111pp","M220119pp",
    "M22.02pp", "M22.03pp", "M22.04pp", "M22.05pp", "M22.06pp", "M22.07pp", "M23pp", "M24pp",
    "M25pp", "M26pp", "M27pp", "M28pp", "M22.99pp", "M30pp","M40pp","M50pp","M60pp","M99pp"
]



#As a percentage
ARIESAT_percentages=np.array(ARIESAT_values)/((4479.7+M30+M40+M50+M60)*1.35)*100

copy_file('CASstructure.tex')
for placeholder, cost_val in zip(percent_placeholders, percent_vals):
    overwrite_variable('CASstructure.tex', placeholder, round(cost_val))

for placeholder, cost_val in zip(placeholders, cost_vals):
    overwrite_variable('CASstructure.tex', placeholder, round(cost_val))


for placeholder, percent in zip(ARIESAT_percentages_p, ARIESAT_percentages):
    overwrite_variable('CASstructure.tex', placeholder, percent if percent != "-" else "-")

for placeholder, percent in zip(ARIESAT_value_placeholders, ARIESAT_values):
    overwrite_variable('CASstructure.tex', placeholder, percent if percent != "-" else "-")

"""# Git Upload"""

#Commiting to git
#LATEX
# Define the list of filenames
file_names = ["CAS100000","CAS200000","CAS210000","CAS220000", "CAS220101_MFE_DT", "CAS220102", "CAS220103_MFE_DT_tokamak",
    "CAS220104_MFE_DT","CAS220105", "CAS220106_MFE", "CAS220107_MFE", "CAS220108_MFE","CAS220109_MFE",
    "CAS220111_MFE","CAS220119_MFE", "CAS220200_DT", "CAS220300", "CAS220400","CAS220500_DT",
    "CAS220600", "CAS220700", "CAS230000", "CAS240000",
    "CAS250000", "CAS260000", "CAS270000", "CAS280000",
    "CAS290000","CAS300000", "CAS400000","CAS500000","CAS600000","CAS700000","CAS800000_DT","CAS900000",
    "powerTableMFEDT","CASstructure","LCOE"]

# Copy each file
for file_name in file_names:
    source_file = f"{modified_directory}/{file_name}.tex"
    #destination_file = f"/content/{project}/{file_name}.tex"
    destination_file = f"/content/MFE/Modified/{file_name}.tex"

    !cp "{source_file}" "{destination_file}"

#FIGURES
# Define the list of filenames
figure_file_names = ['radial_build.pdf','cooling_efficiency.pdf']

# Copy each file
for file_name in figure_file_names:
    source_file = f"{figures_directory}/{file_name}"
    #destination_file = f"/content/{project}/{file_name}"
    destination_file = f"/content/MFE/Figures/{file_name}"

    !cp "{source_file}" "{destination_file}"


# Add, commit, and push the files
!git add .
!git commit -m "Updated multiple tex and files"
!git push origin main

"""# Cost preview"""

from pylatex import Document, Section, Table, Tabular, NoEscape, Package,Subsection,Subsubsection, Command, Figure

# Assuming cost_vals is a list of calculated variables
# Initialize the PyLaTeX document
doc = Document()
doc.packages.append(Package('graphicx'))

with doc.create(Section('Cost Accounting Structure')):
    with doc.create(Table(position='h!')) as table:
        # Open resizebox before the tabular starts
        table.append(NoEscape(r'\resizebox{\textwidth}{!}{'))

        with table.create(Tabular('lcccc')) as tabular:
            tabular.add_hline()
            tabular.add_row('', 'Cost (M USD)' , '% of TCC' , 'ARIESAT Cost (M USD)' , 'ARIESAT \% of TCC')
            tabular.add_hline()

            # Define the rows for the table
            row_titles = [
                '10. Pre-construction', '20. Direct Costs', '21. Structures/Site',
                '22. Reactor Plant Equip.', '22.1 Reactor Equip.', '22.1.1 First Wall & Blanket',
                '22.1.2 High Temp. Shield', '22.1.3 Magnets', '22.1.4 Suppl. Heating', '22.1.5 Primary Structure',
                '22.1.6 Vacuum System', '22.1.7 Power Supplies', '22.1.8 Electrodes or Plasma Guns',
                '22.1.9 Direct E. Conv.', '22.1.11 Assembly and installation', '22.2 Main Heat Transfer',
                '22.3 Auxiliary Cooling', '22.4 Rad. Waste Treat.', '22.5 Fuel Processing',
                '22.6 Other plant equipment', '22.7 Instrumentation and control', '23. Turbine Plant Equip.',
                '24. Electric Plant Equip.', '25. Misc. Plant Equip.', '26. Heat Rejection', '27. Special Materials', '28. Digital Twin', '29. Contingency',
                '30. Capitalized Indirect Service Costs (CISC)', '40. Capitalized Owner’s Cost (COC)',
                '50. Capitalized Supplementary Costs (CSC)', '60. Capitalized Financial Costs (CFC)',
                ' Total Capital Cost:'
            ]


            # Combine row titles with cost values
            for title, cost, cost1, cost2, cost3 in zip(row_titles, cost_vals, percent_vals, ARIESAT_values, ARIESAT_percentages):
                cost_str = f'{cost}' if cost is not None else '-'
                cost1_str = f'{cost1:.2f}' if cost1 is not None else '-'
                cost2_str = f'{cost2:.2f}' if cost2 is not None else '-'
                cost3_str = f'{cost3:.2f}' if cost3 is not None else '-'
                tabular.add_row((title, cost_str, cost1_str, cost2_str, cost3_str))

            tabular.add_hline()

        # Close resizebox after the tabular ends
        table.append(NoEscape('}'))

        # Add caption and label for the table
        table.add_caption('Cost accounts')
        table.append(NoEscape(r'\label{tab:costs}'))

# Generate the PDF with PyLaTeX
pdf_filename = 'CostTable'
pdf_filepath = f'/content/drive/MyDrive/2023ARPAECosting/Novatron/Latex/{pdf_filename}'
doc.generate_pdf(pdf_filepath, clean_tex=False)

import time
time.sleep(8)

pdf_filename = 'CostTable'
pdf_filepath = f'/content/drive/MyDrive/2023ARPAECosting/Novatron/Latex/{pdf_filename}'

# Generate the PDF with PyLaTeX
doc.generate_pdf(pdf_filepath, clean_tex=False)

# View file
pdf_link = 'https://drive.google.com/file/d/1-10uhHC2NbrHvvaWDgjRHty_l1rBXzTx/preview'
display(IFrame(pdf_link, width=800, height=1000))